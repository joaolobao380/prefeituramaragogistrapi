{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.initialState = exports[\"default\"] = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _immer = _interopRequireDefault(require(\"immer\"));\n\nvar _lodash = require(\"lodash\");\n\nvar _updateConditionsToFalse = _interopRequireDefault(require(\"./utils/updateConditionsToFalse\"));\n\nvar _updateValues = _interopRequireDefault(require(\"./utils/updateValues\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar initialState = {\n  initialData: {},\n  modifiedData: {},\n  layouts: {}\n};\n/* eslint-disable consistent-return */\n\nexports.initialState = initialState;\n\nvar reducer = function reducer(state, action) {\n  return (0, _immer[\"default\"])(state, function (draftState) {\n    switch (action.type) {\n      // This action is called when a checkbox in the <GlobalActions />\n      // changes\n      case 'ON_CHANGE_COLLECTION_TYPE_GLOBAL_ACTION_CHECKBOX':\n        {\n          var collectionTypeKind = action.collectionTypeKind,\n              actionId = action.actionId,\n              value = action.value;\n          var pathToData = ['modifiedData', collectionTypeKind];\n          Object.keys((0, _lodash.get)(state, pathToData)).forEach(function (collectionType) {\n            var collectionTypeActionData = (0, _lodash.get)(state, [].concat(pathToData, [collectionType, actionId]), undefined);\n\n            if (collectionTypeActionData) {\n              var updatedValues = (0, _updateValues[\"default\"])(collectionTypeActionData, value); // We need to remove the applied conditions\n\n              if (!value && updatedValues.conditions) {\n                var updatedConditions = (0, _updateValues[\"default\"])(updatedValues.conditions, false);\n                updatedValues = _objectSpread(_objectSpread({}, updatedValues), {}, {\n                  conditions: updatedConditions\n                });\n              }\n\n              (0, _lodash.set)(draftState, [].concat(pathToData, [collectionType, actionId]), updatedValues);\n            }\n          });\n          break;\n        }\n\n      case 'ON_CHANGE_COLLECTION_TYPE_ROW_LEFT_CHECKBOX':\n        {\n          var pathToCollectionType = action.pathToCollectionType,\n              propertyName = action.propertyName,\n              rowName = action.rowName,\n              _value = action.value;\n          var nextModifiedDataState = (0, _lodash.cloneDeep)(state.modifiedData);\n          var pathToModifiedDataCollectionType = pathToCollectionType.split('..');\n          var objToUpdate = (0, _lodash.get)(nextModifiedDataState, pathToModifiedDataCollectionType, {});\n          Object.keys(objToUpdate).forEach(function (actionId) {\n            // When a ct has multiple properties (ex: locales, field)\n            // We need to make sure that we add any new property to the modifiedData\n            // object.\n            if ((0, _lodash.has)(objToUpdate[actionId], \"properties.\".concat(propertyName))) {\n              var objValue = (0, _lodash.get)(objToUpdate, [actionId, 'properties', propertyName, rowName]);\n              var pathToDataToSet = [].concat((0, _toConsumableArray2[\"default\"])(pathToModifiedDataCollectionType), [actionId, 'properties', propertyName, rowName]);\n\n              if (!(0, _lodash.isObject)(objValue)) {\n                (0, _lodash.set)(nextModifiedDataState, pathToDataToSet, _value);\n              } else {\n                var updatedValue = (0, _updateValues[\"default\"])(objValue, _value);\n                (0, _lodash.set)(nextModifiedDataState, pathToDataToSet, updatedValue);\n              }\n            }\n          }); // When we uncheck a row, we need to check if we also need to disable the conditions\n\n          if (!_value) {\n            nextModifiedDataState = (0, _updateConditionsToFalse[\"default\"])(nextModifiedDataState);\n          }\n\n          (0, _lodash.set)(draftState, 'modifiedData', nextModifiedDataState);\n          break;\n        }\n\n      case 'ON_CHANGE_CONDITIONS':\n        {\n          Object.entries(action.conditions).forEach(function (array) {\n            var _array = (0, _slicedToArray2[\"default\"])(array, 2),\n                stringPathToData = _array[0],\n                conditionsToUpdate = _array[1];\n\n            (0, _lodash.set)(draftState, ['modifiedData'].concat((0, _toConsumableArray2[\"default\"])(stringPathToData.split('..')), ['conditions']), conditionsToUpdate);\n          });\n          break;\n        }\n\n      case 'ON_CHANGE_SIMPLE_CHECKBOX':\n        {\n          var _nextModifiedDataState = (0, _lodash.cloneDeep)(state.modifiedData);\n\n          (0, _lodash.set)(_nextModifiedDataState, (0, _toConsumableArray2[\"default\"])(action.keys.split('..')), action.value); // When we uncheck a single checkbox we need to remove the conditions from the parent\n\n          if (!action.value) {\n            _nextModifiedDataState = (0, _updateConditionsToFalse[\"default\"])(_nextModifiedDataState);\n          }\n\n          (0, _lodash.set)(draftState, 'modifiedData', _nextModifiedDataState);\n          break;\n        }\n\n      /*\n       * Here the idea is to retrieve a specific value of the modifiedObject\n       * then update all the boolean values of the retrieved one\n       * and update the drafState.\n       *\n       * For instance in order to enable create action for all the fields and locales\n       * of the restaurant content type we need to :\n       * 1. Retrieve the modifiedData.collectionTypes.restaurant.create object\n       * 2. Toggle all the end boolean values to the desired one\n       * 3. Update the draftState\n       *\n       * Since the case works well in order to update what we called \"parent\" checkbox. We can\n       * reuse the action when we need to toggle change all the values that depends on this one.\n       * A parent checkbox is a checkbox which value is not a boolean but depends on its children ones, therefore,\n       * a parent checkbox does not have a represented value in the draftState, they are just helpers.\n       *\n       * Given the following data:\n       *\n       * const data = {\n       *  restaurant: {\n       *   create: {\n       *     fields: { name: true },\n       *     locales: { en: false }\n       *   }\n       *  }\n       * }\n       *\n       * The value of the create checkbox for the restaurant will be Æ’alse since not all its children have\n       * truthy values and in order to set its value to true when need to have all the values of its children set to true.\n       *\n       * Similarly, we can reuse the logic for the components attributes\n       *\n       */\n\n      case 'ON_CHANGE_TOGGLE_PARENT_CHECKBOX':\n        {\n          var keys = action.keys,\n              _value2 = action.value;\n          var pathToValue = (0, _toConsumableArray2[\"default\"])(keys.split('..'));\n\n          var _nextModifiedDataState2 = (0, _lodash.cloneDeep)(state.modifiedData);\n\n          var oldValues = (0, _lodash.get)(_nextModifiedDataState2, pathToValue, {});\n          var updatedValues = (0, _updateValues[\"default\"])(oldValues, _value2);\n          (0, _lodash.set)(_nextModifiedDataState2, pathToValue, updatedValues); // When we uncheck a parent checkbox we need to remove the associated conditions\n\n          if (!_value2) {\n            _nextModifiedDataState2 = (0, _updateConditionsToFalse[\"default\"])(_nextModifiedDataState2);\n          }\n\n          (0, _lodash.set)(draftState, ['modifiedData'], _nextModifiedDataState2);\n          break;\n        }\n\n      case 'RESET_FORM':\n        {\n          draftState.modifiedData = state.initialData;\n          break;\n        }\n\n      case 'SET_FORM_AFTER_SUBMIT':\n        {\n          draftState.initialData = state.modifiedData;\n          break;\n        }\n\n      default:\n        return draftState;\n    }\n  });\n};\n\nvar _default = reducer;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/Users/joaovictorlobao/prefeituramaragogistrapi/.cache/admin/src/components/Roles/Permissions/reducer.js"],"names":["initialState","initialData","modifiedData","layouts","reducer","state","action","draftState","type","collectionTypeKind","actionId","value","pathToData","Object","keys","forEach","collectionType","collectionTypeActionData","undefined","updatedValues","conditions","updatedConditions","pathToCollectionType","propertyName","rowName","nextModifiedDataState","pathToModifiedDataCollectionType","split","objToUpdate","objValue","pathToDataToSet","updatedValue","entries","array","stringPathToData","conditionsToUpdate","pathToValue","oldValues"],"mappings":"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","sourcesContent":["import produce from 'immer';\nimport { cloneDeep, has, isObject, get, set } from 'lodash';\nimport updateConditionsToFalse from './utils/updateConditionsToFalse';\nimport updateValues from './utils/updateValues';\n\nconst initialState = {\n  initialData: {},\n  modifiedData: {},\n  layouts: {},\n};\n\n/* eslint-disable consistent-return */\nconst reducer = (state, action) =>\n  produce(state, draftState => {\n    switch (action.type) {\n      // This action is called when a checkbox in the <GlobalActions />\n      // changes\n      case 'ON_CHANGE_COLLECTION_TYPE_GLOBAL_ACTION_CHECKBOX': {\n        const { collectionTypeKind, actionId, value } = action;\n        const pathToData = ['modifiedData', collectionTypeKind];\n\n        Object.keys(get(state, pathToData)).forEach(collectionType => {\n          const collectionTypeActionData = get(\n            state,\n            [...pathToData, collectionType, actionId],\n            undefined\n          );\n\n          if (collectionTypeActionData) {\n            let updatedValues = updateValues(collectionTypeActionData, value);\n\n            // We need to remove the applied conditions\n            if (!value && updatedValues.conditions) {\n              const updatedConditions = updateValues(updatedValues.conditions, false);\n\n              updatedValues = { ...updatedValues, conditions: updatedConditions };\n            }\n\n            set(draftState, [...pathToData, collectionType, actionId], updatedValues);\n          }\n        });\n\n        break;\n      }\n      case 'ON_CHANGE_COLLECTION_TYPE_ROW_LEFT_CHECKBOX': {\n        const { pathToCollectionType, propertyName, rowName, value } = action;\n        let nextModifiedDataState = cloneDeep(state.modifiedData);\n        const pathToModifiedDataCollectionType = pathToCollectionType.split('..');\n\n        const objToUpdate = get(nextModifiedDataState, pathToModifiedDataCollectionType, {});\n\n        Object.keys(objToUpdate).forEach(actionId => {\n          // When a ct has multiple properties (ex: locales, field)\n          // We need to make sure that we add any new property to the modifiedData\n          // object.\n          if (has(objToUpdate[actionId], `properties.${propertyName}`)) {\n            const objValue = get(objToUpdate, [actionId, 'properties', propertyName, rowName]);\n            const pathToDataToSet = [\n              ...pathToModifiedDataCollectionType,\n              actionId,\n              'properties',\n              propertyName,\n              rowName,\n            ];\n\n            if (!isObject(objValue)) {\n              set(nextModifiedDataState, pathToDataToSet, value);\n            } else {\n              const updatedValue = updateValues(objValue, value);\n\n              set(nextModifiedDataState, pathToDataToSet, updatedValue);\n            }\n          }\n        });\n\n        // When we uncheck a row, we need to check if we also need to disable the conditions\n        if (!value) {\n          nextModifiedDataState = updateConditionsToFalse(nextModifiedDataState);\n        }\n\n        set(draftState, 'modifiedData', nextModifiedDataState);\n\n        break;\n      }\n      case 'ON_CHANGE_CONDITIONS': {\n        Object.entries(action.conditions).forEach(array => {\n          const [stringPathToData, conditionsToUpdate] = array;\n\n          set(\n            draftState,\n            ['modifiedData', ...stringPathToData.split('..'), 'conditions'],\n            conditionsToUpdate\n          );\n        });\n\n        break;\n      }\n      case 'ON_CHANGE_SIMPLE_CHECKBOX': {\n        let nextModifiedDataState = cloneDeep(state.modifiedData);\n\n        set(nextModifiedDataState, [...action.keys.split('..')], action.value);\n\n        // When we uncheck a single checkbox we need to remove the conditions from the parent\n        if (!action.value) {\n          nextModifiedDataState = updateConditionsToFalse(nextModifiedDataState);\n        }\n\n        set(draftState, 'modifiedData', nextModifiedDataState);\n\n        break;\n      }\n      /*\n       * Here the idea is to retrieve a specific value of the modifiedObject\n       * then update all the boolean values of the retrieved one\n       * and update the drafState.\n       *\n       * For instance in order to enable create action for all the fields and locales\n       * of the restaurant content type we need to :\n       * 1. Retrieve the modifiedData.collectionTypes.restaurant.create object\n       * 2. Toggle all the end boolean values to the desired one\n       * 3. Update the draftState\n       *\n       * Since the case works well in order to update what we called \"parent\" checkbox. We can\n       * reuse the action when we need to toggle change all the values that depends on this one.\n       * A parent checkbox is a checkbox which value is not a boolean but depends on its children ones, therefore,\n       * a parent checkbox does not have a represented value in the draftState, they are just helpers.\n       *\n       * Given the following data:\n       *\n       * const data = {\n       *  restaurant: {\n       *   create: {\n       *     fields: { name: true },\n       *     locales: { en: false }\n       *   }\n       *  }\n       * }\n       *\n       * The value of the create checkbox for the restaurant will be Æ’alse since not all its children have\n       * truthy values and in order to set its value to true when need to have all the values of its children set to true.\n       *\n       * Similarly, we can reuse the logic for the components attributes\n       *\n       */\n      case 'ON_CHANGE_TOGGLE_PARENT_CHECKBOX': {\n        const { keys, value } = action;\n        const pathToValue = [...keys.split('..')];\n        let nextModifiedDataState = cloneDeep(state.modifiedData);\n        const oldValues = get(nextModifiedDataState, pathToValue, {});\n\n        const updatedValues = updateValues(oldValues, value);\n        set(nextModifiedDataState, pathToValue, updatedValues);\n\n        // When we uncheck a parent checkbox we need to remove the associated conditions\n        if (!value) {\n          nextModifiedDataState = updateConditionsToFalse(nextModifiedDataState);\n        }\n\n        set(draftState, ['modifiedData'], nextModifiedDataState);\n\n        break;\n      }\n      case 'RESET_FORM': {\n        draftState.modifiedData = state.initialData;\n        break;\n      }\n      case 'SET_FORM_AFTER_SUBMIT': {\n        draftState.initialData = state.modifiedData;\n        break;\n      }\n      default:\n        return draftState;\n    }\n  });\n\nexport default reducer;\nexport { initialState };\n"]},"metadata":{},"sourceType":"script"}