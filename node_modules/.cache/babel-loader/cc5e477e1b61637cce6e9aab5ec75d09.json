{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.helperCleanData = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _lodash = require(\"lodash\");\n\n/* eslint-disable indent */\nvar cleanData = function cleanData(retrievedData, currentSchema, componentsSchema) {\n  var getType = function getType(schema, attrName) {\n    return (0, _lodash.get)(schema, ['attributes', attrName, 'type'], '');\n  };\n\n  var getOtherInfos = function getOtherInfos(schema, arr) {\n    return (0, _lodash.get)(schema, ['attributes'].concat((0, _toConsumableArray2[\"default\"])(arr)), '');\n  };\n\n  var recursiveCleanData = function recursiveCleanData(data, schema) {\n    return Object.keys(data).reduce(function (acc, current) {\n      var attrType = getType(schema, current);\n      var value = (0, _lodash.get)(data, current);\n      var component = getOtherInfos(schema, [current, 'component']);\n      var isRepeatable = getOtherInfos(schema, [current, 'repeatable']);\n      var cleanedData;\n\n      switch (attrType) {\n        case 'json':\n          try {\n            cleanedData = JSON.parse(value);\n          } catch (err) {\n            cleanedData = value;\n          }\n\n          break;\n\n        case 'date':\n        case 'datetime':\n          cleanedData = value && value._isAMomentObject === true ? value.toISOString() : value;\n          break;\n\n        case 'media':\n          if (getOtherInfos(schema, [current, 'multiple']) === true) {\n            cleanedData = value ? value.filter(function (file) {\n              return !(file instanceof File);\n            }) : null;\n          } else {\n            cleanedData = (0, _lodash.get)(value, 0) instanceof File ? null : (0, _lodash.get)(value, 'id', null);\n          }\n\n          break;\n\n        case 'component':\n          if (isRepeatable) {\n            cleanedData = value ? value.map(function (data) {\n              var subCleanedData = recursiveCleanData(data, componentsSchema[component]);\n              return subCleanedData;\n            }) : value;\n          } else {\n            cleanedData = value ? recursiveCleanData(value, componentsSchema[component]) : value;\n          }\n\n          break;\n\n        case 'dynamiczone':\n          cleanedData = value.map(function (componentData) {\n            var subCleanedData = recursiveCleanData(componentData, componentsSchema[componentData.__component]);\n            return subCleanedData;\n          });\n          break;\n\n        default:\n          // The helper is mainly used for the relations in order to just send the id\n          cleanedData = helperCleanData(value, 'id');\n      }\n\n      acc[current] = cleanedData;\n      return acc;\n    }, {});\n  };\n\n  return recursiveCleanData(retrievedData, currentSchema);\n};\n\nvar helperCleanData = function helperCleanData(value, key) {\n  if ((0, _lodash.isArray)(value)) {\n    return value.map(function (obj) {\n      return obj[key] ? obj[key] : obj;\n    });\n  }\n\n  if ((0, _lodash.isObject)(value)) {\n    return value[key];\n  }\n\n  return value;\n};\n\nexports.helperCleanData = helperCleanData;\nvar _default = cleanData;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/Users/joaovictorlobao/prefeituramaragogistrapi/.cache/plugins/strapi-plugin-content-manager/admin/src/containers/EditViewDataManagerProvider/utils/cleanData.js"],"names":["cleanData","retrievedData","currentSchema","componentsSchema","getType","schema","attrName","getOtherInfos","arr","recursiveCleanData","data","Object","keys","reduce","acc","current","attrType","value","component","isRepeatable","cleanedData","JSON","parse","err","_isAMomentObject","toISOString","filter","file","File","map","subCleanedData","componentData","__component","helperCleanData","key","obj"],"mappings":"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","sourcesContent":["import { get, isArray, isObject } from 'lodash';\n\n/* eslint-disable indent */\n\nconst cleanData = (retrievedData, currentSchema, componentsSchema) => {\n  const getType = (schema, attrName) => get(schema, ['attributes', attrName, 'type'], '');\n  const getOtherInfos = (schema, arr) => get(schema, ['attributes', ...arr], '');\n\n  const recursiveCleanData = (data, schema) => {\n    return Object.keys(data).reduce((acc, current) => {\n      const attrType = getType(schema, current);\n      const value = get(data, current);\n      const component = getOtherInfos(schema, [current, 'component']);\n      const isRepeatable = getOtherInfos(schema, [current, 'repeatable']);\n      let cleanedData;\n\n      switch (attrType) {\n        case 'json':\n          try {\n            cleanedData = JSON.parse(value);\n          } catch (err) {\n            cleanedData = value;\n          }\n\n          break;\n        case 'date':\n        case 'datetime':\n          cleanedData = value && value._isAMomentObject === true ? value.toISOString() : value;\n          break;\n        case 'media':\n          if (getOtherInfos(schema, [current, 'multiple']) === true) {\n            cleanedData = value ? value.filter(file => !(file instanceof File)) : null;\n          } else {\n            cleanedData = get(value, 0) instanceof File ? null : get(value, 'id', null);\n          }\n          break;\n        case 'component':\n          if (isRepeatable) {\n            cleanedData = value\n              ? value.map(data => {\n                  const subCleanedData = recursiveCleanData(data, componentsSchema[component]);\n\n                  return subCleanedData;\n                })\n              : value;\n          } else {\n            cleanedData = value ? recursiveCleanData(value, componentsSchema[component]) : value;\n          }\n          break;\n        case 'dynamiczone':\n          cleanedData = value.map(componentData => {\n            const subCleanedData = recursiveCleanData(\n              componentData,\n              componentsSchema[componentData.__component]\n            );\n\n            return subCleanedData;\n          });\n          break;\n        default:\n          // The helper is mainly used for the relations in order to just send the id\n          cleanedData = helperCleanData(value, 'id');\n      }\n\n      acc[current] = cleanedData;\n\n      return acc;\n    }, {});\n  };\n\n  return recursiveCleanData(retrievedData, currentSchema);\n};\n\nexport const helperCleanData = (value, key) => {\n  if (isArray(value)) {\n    return value.map(obj => (obj[key] ? obj[key] : obj));\n  }\n  if (isObject(value)) {\n    return value[key];\n  }\n\n  return value;\n};\n\nexport default cleanData;\n"]},"metadata":{},"sourceType":"script"}