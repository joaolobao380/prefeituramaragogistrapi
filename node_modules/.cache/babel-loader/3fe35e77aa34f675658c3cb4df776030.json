{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.injectSagaFactory = injectSagaFactory;\nexports.ejectSagaFactory = ejectSagaFactory;\nexports[\"default\"] = getInjectors;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _isEmpty = _interopRequireDefault(require(\"lodash/isEmpty\"));\n\nvar _isFunction = _interopRequireDefault(require(\"lodash/isFunction\"));\n\nvar _isString = _interopRequireDefault(require(\"lodash/isString\"));\n\nvar _invariant = _interopRequireDefault(require(\"invariant\"));\n\nvar _conformsTo = _interopRequireDefault(require(\"lodash/conformsTo\"));\n\nvar _checkStore = _interopRequireDefault(require(\"./checkStore\"));\n\nvar _constants = require(\"./constants\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar allowedModes = [_constants.RESTART_ON_REMOUNT, _constants.DAEMON, _constants.ONCE_TILL_UNMOUNT];\n\nvar checkKey = function checkKey(key) {\n  return (0, _invariant[\"default\"])((0, _isString[\"default\"])(key) && !(0, _isEmpty[\"default\"])(key), '(app/utils...) injectSaga: Expected `key` to be a non empty string');\n};\n\nvar checkDescriptor = function checkDescriptor(descriptor) {\n  var shape = {\n    saga: _isFunction[\"default\"],\n    mode: function mode(_mode) {\n      return (0, _isString[\"default\"])(_mode) && allowedModes.includes(_mode);\n    }\n  };\n  (0, _invariant[\"default\"])((0, _conformsTo[\"default\"])(descriptor, shape), '(app/utils...) injectSaga: Expected a valid saga descriptor');\n};\n\nfunction injectSagaFactory(store, isValid) {\n  return function injectSaga(key) {\n    var descriptor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var args = arguments.length > 2 ? arguments[2] : undefined;\n    if (!isValid) (0, _checkStore[\"default\"])(store);\n\n    var newDescriptor = _objectSpread(_objectSpread({}, descriptor), {}, {\n      mode: descriptor.mode || _constants.RESTART_ON_REMOUNT\n    });\n\n    var saga = newDescriptor.saga,\n        mode = newDescriptor.mode;\n    checkKey(key);\n    checkDescriptor(newDescriptor);\n    var hasSaga = Reflect.has(store.injectedSagas, key);\n\n    if (process.env.NODE_ENV !== 'production') {\n      var oldDescriptor = store.injectedSagas[key]; // enable hot reloading of daemon and once-till-unmount sagas\n\n      if (hasSaga && oldDescriptor.saga !== saga) {\n        oldDescriptor.task.cancel();\n        hasSaga = false;\n      }\n    }\n\n    if (!hasSaga || hasSaga && mode !== _constants.DAEMON && mode !== _constants.ONCE_TILL_UNMOUNT) {\n      store.injectedSagas[key] = _objectSpread(_objectSpread({}, newDescriptor), {}, {\n        task: store.runSaga(saga, args)\n      }); // eslint-disable-line no-param-reassign\n    }\n  };\n}\n\nfunction ejectSagaFactory(store, isValid) {\n  return function ejectSaga(key) {\n    if (!isValid) (0, _checkStore[\"default\"])(store);\n    checkKey(key);\n\n    if (Reflect.has(store.injectedSagas, key)) {\n      var descriptor = store.injectedSagas[key];\n\n      if (descriptor.mode !== _constants.DAEMON) {\n        descriptor.task.cancel(); // Clean up in production; in development we need `descriptor.saga` for hot reloading\n\n        if (process.env.NODE_ENV === 'production') {\n          // Need some value to be able to detect `ONCE_TILL_UNMOUNT` sagas in `injectSaga`\n          store.injectedSagas[key] = 'done'; // eslint-disable-line no-param-reassign\n        }\n      }\n    }\n  };\n}\n\nfunction getInjectors(store) {\n  (0, _checkStore[\"default\"])(store);\n  return {\n    injectSaga: injectSagaFactory(store, true),\n    ejectSaga: ejectSagaFactory(store, true)\n  };\n}","map":{"version":3,"sources":["/Users/joaovictorlobao/prefeituramaragogistrapi/.cache/admin/src/utils/sagaInjectors.js"],"names":["allowedModes","RESTART_ON_REMOUNT","DAEMON","ONCE_TILL_UNMOUNT","checkKey","key","checkDescriptor","descriptor","shape","saga","isFunction","mode","includes","injectSagaFactory","store","isValid","injectSaga","args","newDescriptor","hasSaga","Reflect","has","injectedSagas","process","env","NODE_ENV","oldDescriptor","task","cancel","runSaga","ejectSagaFactory","ejectSaga","getInjectors"],"mappings":";;;;;;;;;;;;;AAEA;;AACA;;AACA;;AACA;;AACA;;AAEA;;AACA;;;;;;AAEA,IAAMA,YAAY,GAAG,CAACC,6BAAD,EAAqBC,iBAArB,EAA6BC,4BAA7B,CAArB;;AAEA,IAAMC,QAAQ,GAAG,SAAXA,QAAW,CAAAC,GAAG;AAAA,SAClB,2BACE,0BAASA,GAAT,KAAiB,CAAC,yBAAQA,GAAR,CADpB,EAEE,oEAFF,CADkB;AAAA,CAApB;;AAMA,IAAMC,eAAe,GAAG,SAAlBA,eAAkB,CAAAC,UAAU,EAAI;AACpC,MAAMC,KAAK,GAAG;AACZC,IAAAA,IAAI,EAAEC,sBADM;AAEZC,IAAAA,IAAI,EAAE,cAAAA,KAAI;AAAA,aAAI,0BAASA,KAAT,KAAkBX,YAAY,CAACY,QAAb,CAAsBD,KAAtB,CAAtB;AAAA;AAFE,GAAd;AAIA,6BACE,4BAAWJ,UAAX,EAAuBC,KAAvB,CADF,EAEE,6DAFF;AAID,CATD;;AAWO,SAASK,iBAAT,CAA2BC,KAA3B,EAAkCC,OAAlC,EAA2C;AAChD,SAAO,SAASC,UAAT,CAAoBX,GAApB,EAAgD;AAAA,QAAvBE,UAAuB,uEAAV,EAAU;AAAA,QAANU,IAAM;AACrD,QAAI,CAACF,OAAL,EAAc,4BAAWD,KAAX;;AAEd,QAAMI,aAAa,mCACdX,UADc;AAEjBI,MAAAA,IAAI,EAAEJ,UAAU,CAACI,IAAX,IAAmBV;AAFR,MAAnB;;AAIA,QAAQQ,IAAR,GAAuBS,aAAvB,CAAQT,IAAR;AAAA,QAAcE,IAAd,GAAuBO,aAAvB,CAAcP,IAAd;AAEAP,IAAAA,QAAQ,CAACC,GAAD,CAAR;AACAC,IAAAA,eAAe,CAACY,aAAD,CAAf;AAEA,QAAIC,OAAO,GAAGC,OAAO,CAACC,GAAR,CAAYP,KAAK,CAACQ,aAAlB,EAAiCjB,GAAjC,CAAd;;AAEA,QAAIkB,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC,UAAMC,aAAa,GAAGZ,KAAK,CAACQ,aAAN,CAAoBjB,GAApB,CAAtB,CADyC,CAEzC;;AACA,UAAIc,OAAO,IAAIO,aAAa,CAACjB,IAAd,KAAuBA,IAAtC,EAA4C;AAC1CiB,QAAAA,aAAa,CAACC,IAAd,CAAmBC,MAAnB;AACAT,QAAAA,OAAO,GAAG,KAAV;AACD;AACF;;AAED,QACE,CAACA,OAAD,IACCA,OAAO,IAAIR,IAAI,KAAKT,iBAApB,IAA8BS,IAAI,KAAKR,4BAF1C,EAGE;AACAW,MAAAA,KAAK,CAACQ,aAAN,CAAoBjB,GAApB,oCACKa,aADL;AAEES,QAAAA,IAAI,EAAEb,KAAK,CAACe,OAAN,CAAcpB,IAAd,EAAoBQ,IAApB;AAFR,SADA,CAIG;AACJ;AACF,GAhCD;AAiCD;;AAEM,SAASa,gBAAT,CAA0BhB,KAA1B,EAAiCC,OAAjC,EAA0C;AAC/C,SAAO,SAASgB,SAAT,CAAmB1B,GAAnB,EAAwB;AAC7B,QAAI,CAACU,OAAL,EAAc,4BAAWD,KAAX;AAEdV,IAAAA,QAAQ,CAACC,GAAD,CAAR;;AAEA,QAAIe,OAAO,CAACC,GAAR,CAAYP,KAAK,CAACQ,aAAlB,EAAiCjB,GAAjC,CAAJ,EAA2C;AACzC,UAAME,UAAU,GAAGO,KAAK,CAACQ,aAAN,CAAoBjB,GAApB,CAAnB;;AACA,UAAIE,UAAU,CAACI,IAAX,KAAoBT,iBAAxB,EAAgC;AAC9BK,QAAAA,UAAU,CAACoB,IAAX,CAAgBC,MAAhB,GAD8B,CAE9B;;AACA,YAAIL,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC;AACAX,UAAAA,KAAK,CAACQ,aAAN,CAAoBjB,GAApB,IAA2B,MAA3B,CAFyC,CAEN;AACpC;AACF;AACF;AACF,GAhBD;AAiBD;;AAEc,SAAS2B,YAAT,CAAsBlB,KAAtB,EAA6B;AAC1C,8BAAWA,KAAX;AAEA,SAAO;AACLE,IAAAA,UAAU,EAAEH,iBAAiB,CAACC,KAAD,EAAQ,IAAR,CADxB;AAELiB,IAAAA,SAAS,EAAED,gBAAgB,CAAChB,KAAD,EAAQ,IAAR;AAFtB,GAAP;AAID","sourcesContent":["/* eslint-disable */\n\nimport isEmpty from 'lodash/isEmpty';\nimport isFunction from 'lodash/isFunction';\nimport isString from 'lodash/isString';\nimport invariant from 'invariant';\nimport conformsTo from 'lodash/conformsTo';\n\nimport checkStore from './checkStore';\nimport { DAEMON, ONCE_TILL_UNMOUNT, RESTART_ON_REMOUNT } from './constants';\n\nconst allowedModes = [RESTART_ON_REMOUNT, DAEMON, ONCE_TILL_UNMOUNT];\n\nconst checkKey = key =>\n  invariant(\n    isString(key) && !isEmpty(key),\n    '(app/utils...) injectSaga: Expected `key` to be a non empty string'\n  );\n\nconst checkDescriptor = descriptor => {\n  const shape = {\n    saga: isFunction,\n    mode: mode => isString(mode) && allowedModes.includes(mode),\n  };\n  invariant(\n    conformsTo(descriptor, shape),\n    '(app/utils...) injectSaga: Expected a valid saga descriptor'\n  );\n};\n\nexport function injectSagaFactory(store, isValid) {\n  return function injectSaga(key, descriptor = {}, args) {\n    if (!isValid) checkStore(store);\n\n    const newDescriptor = {\n      ...descriptor,\n      mode: descriptor.mode || RESTART_ON_REMOUNT,\n    };\n    const { saga, mode } = newDescriptor;\n\n    checkKey(key);\n    checkDescriptor(newDescriptor);\n\n    let hasSaga = Reflect.has(store.injectedSagas, key);\n\n    if (process.env.NODE_ENV !== 'production') {\n      const oldDescriptor = store.injectedSagas[key];\n      // enable hot reloading of daemon and once-till-unmount sagas\n      if (hasSaga && oldDescriptor.saga !== saga) {\n        oldDescriptor.task.cancel();\n        hasSaga = false;\n      }\n    }\n\n    if (\n      !hasSaga ||\n      (hasSaga && mode !== DAEMON && mode !== ONCE_TILL_UNMOUNT)\n    ) {\n      store.injectedSagas[key] = {\n        ...newDescriptor,\n        task: store.runSaga(saga, args),\n      }; // eslint-disable-line no-param-reassign\n    }\n  };\n}\n\nexport function ejectSagaFactory(store, isValid) {\n  return function ejectSaga(key) {\n    if (!isValid) checkStore(store);\n\n    checkKey(key);\n\n    if (Reflect.has(store.injectedSagas, key)) {\n      const descriptor = store.injectedSagas[key];\n      if (descriptor.mode !== DAEMON) {\n        descriptor.task.cancel();\n        // Clean up in production; in development we need `descriptor.saga` for hot reloading\n        if (process.env.NODE_ENV === 'production') {\n          // Need some value to be able to detect `ONCE_TILL_UNMOUNT` sagas in `injectSaga`\n          store.injectedSagas[key] = 'done'; // eslint-disable-line no-param-reassign\n        }\n      }\n    }\n  };\n}\n\nexport default function getInjectors(store) {\n  checkStore(store);\n\n  return {\n    injectSaga: injectSagaFactory(store, true),\n    ejectSaga: ejectSagaFactory(store, true),\n  };\n}\n"]},"metadata":{},"sourceType":"script"}