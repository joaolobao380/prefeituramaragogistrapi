{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useInjectSaga = exports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _hoistNonReactStatics = _interopRequireDefault(require(\"hoist-non-react-statics\"));\n\nvar _reactRedux = require(\"react-redux\");\n\nvar _sagaInjectors = _interopRequireDefault(require(\"./sagaInjectors\"));\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2[\"default\"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2[\"default\"])(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * Dynamically injects a saga, passes component's props as saga arguments\n *\n * @param {string} key A key of the saga\n * @param {function} saga A root saga that will be injected\n * @param {string} [mode] By default (constants.RESTART_ON_REMOUNT) the saga will be started on component mount and\n * cancelled with `task.cancel()` on component un-mount for improved performance. Another two options:\n *   - constants.DAEMON—starts the saga on component mount and never cancels it or starts again,\n *   - constants.ONCE_TILL_UNMOUNT—behaves like 'RESTART_ON_REMOUNT' but never runs it again.\n *\n */\nvar _default = function _default(_ref) {\n  var key = _ref.key,\n      saga = _ref.saga,\n      mode = _ref.mode,\n      pluginId = _ref.pluginId;\n  return function (WrappedComponent) {\n    var InjectSaga = /*#__PURE__*/function (_React$Component) {\n      (0, _inherits2[\"default\"])(InjectSaga, _React$Component);\n\n      var _super = _createSuper(InjectSaga);\n\n      function InjectSaga(props, context) {\n        var _this;\n\n        (0, _classCallCheck2[\"default\"])(this, InjectSaga);\n        _this = _super.call(this, props, context);\n        (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"injectors\", (0, _sagaInjectors[\"default\"])(_this.context.store));\n        _this.injectors = (0, _sagaInjectors[\"default\"])(context.store);\n        var sagaName = pluginId ? \"\".concat(pluginId, \"_\").concat(key) : key;\n        console.warn('Warning: strapi.injectSaga will be removed in the next major release. \\n Please update your code.');\n\n        _this.injectors.injectSaga(sagaName, {\n          saga: saga,\n          mode: mode\n        }, _this.props);\n\n        return _this;\n      }\n\n      (0, _createClass2[\"default\"])(InjectSaga, [{\n        key: \"componentWillUnmount\",\n        value: function componentWillUnmount() {\n          var ejectSaga = this.injectors.ejectSaga;\n          var sagaName = pluginId ? \"\".concat(pluginId, \"_\").concat(key) : key;\n          ejectSaga(sagaName);\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          return /*#__PURE__*/_react[\"default\"].createElement(WrappedComponent, this.props);\n        }\n      }]);\n      return InjectSaga;\n    }(_react[\"default\"].Component);\n\n    (0, _defineProperty2[\"default\"])(InjectSaga, \"WrappedComponent\", WrappedComponent);\n    (0, _defineProperty2[\"default\"])(InjectSaga, \"displayName\", \"withSaga(\".concat(WrappedComponent.displayName || WrappedComponent.name || 'Component', \")\"));\n    (0, _defineProperty2[\"default\"])(InjectSaga, \"contextType\", _reactRedux.ReactReduxContext);\n    return (0, _hoistNonReactStatics[\"default\"])(InjectSaga, WrappedComponent);\n  };\n};\n\nexports[\"default\"] = _default;\n\nvar useInjectSaga = function useInjectSaga(_ref2) {\n  var key = _ref2.key,\n      saga = _ref2.saga,\n      mode = _ref2.mode,\n      pluginId = _ref2.pluginId;\n\n  var context = _react[\"default\"].useContext(_reactRedux.ReactReduxContext);\n\n  var sagaName = pluginId ? \"\".concat(pluginId, \"_\").concat(key) : key;\n\n  _react[\"default\"].useEffect(function () {\n    var injectors = (0, _sagaInjectors[\"default\"])(context.store);\n    injectors.injectSaga(sagaName, {\n      saga: saga,\n      mode: mode\n    });\n    console.warn('Warning: strapi.useInjectSaga will be removed in the next major release. \\n Please update your code.');\n    return function () {\n      injectors.ejectSaga(sagaName);\n    };\n  }, []);\n};\n\nexports.useInjectSaga = useInjectSaga;","map":{"version":3,"sources":["/Users/joaovictorlobao/prefeituramaragogistrapi/.cache/admin/src/utils/injectSaga.js"],"names":["key","saga","mode","pluginId","WrappedComponent","InjectSaga","props","context","store","injectors","sagaName","console","warn","injectSaga","ejectSaga","React","Component","displayName","name","ReactReduxContext","useInjectSaga","useContext","useEffect"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AACA;;AACA;;AACA;;AAEA;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;eACe;AAAA,MAAGA,GAAH,QAAGA,GAAH;AAAA,MAAQC,IAAR,QAAQA,IAAR;AAAA,MAAcC,IAAd,QAAcA,IAAd;AAAA,MAAoBC,QAApB,QAAoBA,QAApB;AAAA,SAAmC,UAAAC,gBAAgB,EAAI;AAAA,QAC9DC,UAD8D;AAAA;;AAAA;;AASlE,0BAAYC,KAAZ,EAAmBC,OAAnB,EAA4B;AAAA;;AAAA;AAC1B,kCAAMD,KAAN,EAAaC,OAAb;AAD0B,sGAoBhB,+BAAa,MAAKA,OAAL,CAAaC,KAA1B,CApBgB;AAG1B,cAAKC,SAAL,GAAiB,+BAAaF,OAAO,CAACC,KAArB,CAAjB;AACA,YAAME,QAAQ,GAAGP,QAAQ,aAAMA,QAAN,cAAkBH,GAAlB,IAA0BA,GAAnD;AAEAW,QAAAA,OAAO,CAACC,IAAR,CACE,mGADF;;AAIA,cAAKH,SAAL,CAAeI,UAAf,CAA0BH,QAA1B,EAAoC;AAAET,UAAAA,IAAI,EAAJA,IAAF;AAAQC,UAAAA,IAAI,EAAJA;AAAR,SAApC,EAAoD,MAAKI,KAAzD;;AAV0B;AAW3B;;AApBiE;AAAA;AAAA,eAsBlE,gCAAuB;AACrB,cAAQQ,SAAR,GAAsB,KAAKL,SAA3B,CAAQK,SAAR;AACA,cAAMJ,QAAQ,GAAGP,QAAQ,aAAMA,QAAN,cAAkBH,GAAlB,IAA0BA,GAAnD;AAEAc,UAAAA,SAAS,CAACJ,QAAD,CAAT;AACD;AA3BiE;AAAA;AAAA,eA+BlE,kBAAS;AACP,8BAAO,gCAAC,gBAAD,EAAsB,KAAKJ,KAA3B,CAAP;AACD;AAjCiE;AAAA;AAAA,MAC3CS,kBAAMC,SADqC;;AAAA,qCAC9DX,UAD8D,sBAExCD,gBAFwC;AAAA,qCAC9DC,UAD8D,oCAGjCD,gBAAgB,CAACa,WAAjB,IAC/Bb,gBAAgB,CAACc,IADc,IAE/B,WALgE;AAAA,qCAC9Db,UAD8D,iBAO7Cc,6BAP6C;AAoCpE,WAAO,sCAAqBd,UAArB,EAAiCD,gBAAjC,CAAP;AACD,GArCc;AAAA,C;;;;AAuCf,IAAMgB,aAAa,GAAG,SAAhBA,aAAgB,QAAmC;AAAA,MAAhCpB,GAAgC,SAAhCA,GAAgC;AAAA,MAA3BC,IAA2B,SAA3BA,IAA2B;AAAA,MAArBC,IAAqB,SAArBA,IAAqB;AAAA,MAAfC,QAAe,SAAfA,QAAe;;AACvD,MAAMI,OAAO,GAAGQ,kBAAMM,UAAN,CAAiBF,6BAAjB,CAAhB;;AACA,MAAMT,QAAQ,GAAGP,QAAQ,aAAMA,QAAN,cAAkBH,GAAlB,IAA0BA,GAAnD;;AAEAe,oBAAMO,SAAN,CAAgB,YAAM;AACpB,QAAMb,SAAS,GAAG,+BAAaF,OAAO,CAACC,KAArB,CAAlB;AACAC,IAAAA,SAAS,CAACI,UAAV,CAAqBH,QAArB,EAA+B;AAAET,MAAAA,IAAI,EAAJA,IAAF;AAAQC,MAAAA,IAAI,EAAJA;AAAR,KAA/B;AAEAS,IAAAA,OAAO,CAACC,IAAR,CACE,sGADF;AAIA,WAAO,YAAM;AACXH,MAAAA,SAAS,CAACK,SAAV,CAAoBJ,QAApB;AACD,KAFD;AAGD,GAXD,EAWG,EAXH;AAYD,CAhBD","sourcesContent":["/* eslint-disable */\nimport React from 'react';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport { ReactReduxContext } from 'react-redux';\n\nimport getInjectors from './sagaInjectors';\n\n/**\n * Dynamically injects a saga, passes component's props as saga arguments\n *\n * @param {string} key A key of the saga\n * @param {function} saga A root saga that will be injected\n * @param {string} [mode] By default (constants.RESTART_ON_REMOUNT) the saga will be started on component mount and\n * cancelled with `task.cancel()` on component un-mount for improved performance. Another two options:\n *   - constants.DAEMON—starts the saga on component mount and never cancels it or starts again,\n *   - constants.ONCE_TILL_UNMOUNT—behaves like 'RESTART_ON_REMOUNT' but never runs it again.\n *\n */\nexport default ({ key, saga, mode, pluginId }) => WrappedComponent => {\n  class InjectSaga extends React.Component {\n    static WrappedComponent = WrappedComponent;\n    static displayName = `withSaga(${WrappedComponent.displayName ||\n      WrappedComponent.name ||\n      'Component'})`;\n\n    static contextType = ReactReduxContext;\n\n    constructor(props, context) {\n      super(props, context);\n\n      this.injectors = getInjectors(context.store);\n      const sagaName = pluginId ? `${pluginId}_${key}` : key;\n\n      console.warn(\n        'Warning: strapi.injectSaga will be removed in the next major release. \\n Please update your code.'\n      );\n\n      this.injectors.injectSaga(sagaName, { saga, mode }, this.props);\n    }\n\n    componentWillUnmount() {\n      const { ejectSaga } = this.injectors;\n      const sagaName = pluginId ? `${pluginId}_${key}` : key;\n\n      ejectSaga(sagaName);\n    }\n\n    injectors = getInjectors(this.context.store);\n\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n\n  return hoistNonReactStatics(InjectSaga, WrappedComponent);\n};\n\nconst useInjectSaga = ({ key, saga, mode, pluginId }) => {\n  const context = React.useContext(ReactReduxContext);\n  const sagaName = pluginId ? `${pluginId}_${key}` : key;\n\n  React.useEffect(() => {\n    const injectors = getInjectors(context.store);\n    injectors.injectSaga(sagaName, { saga, mode });\n\n    console.warn(\n      'Warning: strapi.useInjectSaga will be removed in the next major release. \\n Please update your code.'\n    );\n\n    return () => {\n      injectors.ejectSaga(sagaName);\n    };\n  }, []);\n};\n\nexport { useInjectSaga };\n"]},"metadata":{},"sourceType":"script"}