{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.initialState = exports.addComponentsToState = exports[\"default\"] = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _immutable = require(\"immutable\");\n\nvar _lodash = require(\"lodash\");\n\nvar _makeUnique = _interopRequireDefault(require(\"../../utils/makeUnique\"));\n\nvar _retrieveComponentsFromSchema = _interopRequireDefault(require(\"./utils/retrieveComponentsFromSchema\"));\n\nvar actions = _interopRequireWildcard(require(\"./constants\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar initialState = (0, _immutable.fromJS)({\n  components: {},\n  contentTypes: {},\n  initialComponents: {},\n  initialContentTypes: {},\n  initialData: {},\n  modifiedData: {},\n  reservedNames: {},\n  isLoading: true,\n  isLoadingForDataToBeSet: true\n});\nexports.initialState = initialState;\nvar ONE_SIDE_RELATIONS = ['oneWay', 'manyWay'];\n\nvar getOppositeNature = function getOppositeNature(originalNature) {\n  if (originalNature === 'manyToOne') {\n    return 'oneToMany';\n  }\n\n  if (originalNature === 'oneToMany') {\n    return 'manyToOne';\n  }\n\n  return originalNature;\n};\n\nvar addComponentsToState = function addComponentsToState(state, componentToAddUid, objToUpdate) {\n  var newObj = objToUpdate;\n  var componentToAdd = state.getIn(['components', componentToAddUid]);\n  var isTemporaryComponent = componentToAdd.get('isTemporary');\n  var componentToAddSchema = componentToAdd.getIn(['schema', 'attributes']);\n  var hasComponentAlreadyBeenAdded = state.getIn(['modifiedData', 'components', componentToAddUid]) !== undefined; // created components are already in the modifiedData.components\n  // We don't add them because all modifications will be lost\n\n  if (isTemporaryComponent || hasComponentAlreadyBeenAdded) {\n    return newObj;\n  } // Add the added components to the modifiedData.compontnes\n\n\n  newObj = newObj.set(componentToAddUid, componentToAdd);\n  var nestedComponents = (0, _retrieveComponentsFromSchema[\"default\"])(componentToAddSchema.toJS(), state.get('components').toJS()); // We need to add the nested components to the modifiedData.components as well\n\n  nestedComponents.forEach(function (componentUid) {\n    var isTemporary = state.getIn(['components', componentUid, 'isTemporary']) || false;\n    var hasNestedComponentAlreadyBeenAdded = state.getIn(['modifiedData', 'components', componentUid]) !== undefined; // Same logic here otherwise we will lose the modifications added to the components\n\n    if (!isTemporary && !hasNestedComponentAlreadyBeenAdded) {\n      newObj = newObj.set(componentUid, state.getIn(['components', componentUid]));\n    }\n  });\n  return newObj;\n};\n\nexports.addComponentsToState = addComponentsToState;\n\nvar reducer = function reducer() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  var action = arguments.length > 1 ? arguments[1] : undefined;\n\n  switch (action.type) {\n    case actions.ADD_ATTRIBUTE:\n      {\n        var _action$attributeToSe = action.attributeToSet,\n            name = _action$attributeToSe.name,\n            rest = (0, _objectWithoutProperties2[\"default\"])(_action$attributeToSe, [\"name\"]),\n            forTarget = action.forTarget,\n            targetUid = action.targetUid;\n        delete rest.createComponent;\n        var pathToDataToEdit = ['component', 'contentType'].includes(forTarget) ? [forTarget] : [forTarget, targetUid];\n        return state.updateIn(['modifiedData'].concat(pathToDataToEdit, ['schema', 'attributes', name]), function () {\n          return (0, _immutable.fromJS)(rest);\n        }).updateIn(['modifiedData'].concat(pathToDataToEdit, ['schema', 'attributes']), function (obj) {\n          var type = (0, _lodash.get)(rest, 'type', 'relation');\n          var target = (0, _lodash.get)(rest, 'target', null);\n          var nature = (0, _lodash.get)(rest, 'nature', null);\n          var currentUid = state.getIn(['modifiedData'].concat(pathToDataToEdit, ['uid'])); // When the user in creating a relation with the same content type we need to create another attribute\n          // that is the opposite of the created one\n\n          if (type === 'relation' && nature !== 'oneWay' && nature !== 'manyWay' && target === currentUid) {\n            var oppositeAttribute = {\n              nature: getOppositeNature(nature),\n              target: target,\n              unique: rest.unique,\n              // Leave this if we allow the required on the relation\n              // required: rest.required,\n              dominant: nature === 'manyToMany' ? !rest.dominant : null,\n              targetAttribute: name,\n              columnName: rest.targetColumnName,\n              targetColumnName: rest.columnName\n            };\n            return obj.update(rest.targetAttribute, function () {\n              return (0, _immutable.fromJS)(oppositeAttribute);\n            });\n          }\n\n          return obj;\n        }).updateIn(['modifiedData', 'components'], function (existingCompos) {\n          if (action.shouldAddComponentToData) {\n            return addComponentsToState(state, rest.component, existingCompos);\n          }\n\n          return existingCompos;\n        });\n      }\n\n    case actions.ADD_CREATED_COMPONENT_TO_DYNAMIC_ZONE:\n      {\n        var dynamicZoneTarget = action.dynamicZoneTarget,\n            componentsToAdd = action.componentsToAdd;\n        return state.updateIn(['modifiedData', 'contentType', 'schema', 'attributes', dynamicZoneTarget, 'components'], function (list) {\n          return list.concat(componentsToAdd);\n        });\n      }\n\n    case actions.CANCEL_CHANGES:\n      {\n        return state.update('modifiedData', function () {\n          return state.get('initialData');\n        }).update('components', function () {\n          return state.get('initialComponents');\n        });\n      }\n\n    case actions.CHANGE_DYNAMIC_ZONE_COMPONENTS:\n      {\n        var _dynamicZoneTarget = action.dynamicZoneTarget,\n            newComponents = action.newComponents;\n        return state.updateIn(['modifiedData', 'contentType', 'schema', 'attributes', _dynamicZoneTarget, 'components'], function (list) {\n          return (0, _immutable.fromJS)((0, _makeUnique[\"default\"])([].concat((0, _toConsumableArray2[\"default\"])(list.toJS()), (0, _toConsumableArray2[\"default\"])(newComponents))));\n        }).updateIn(['modifiedData', 'components'], function (old) {\n          var componentsSchema = newComponents.reduce(function (acc, current) {\n            return addComponentsToState(state, current, acc);\n          }, old);\n          return componentsSchema;\n        });\n      }\n\n    case actions.CREATE_SCHEMA:\n      {\n        var newSchema = {\n          uid: action.uid,\n          isTemporary: true,\n          schema: _objectSpread(_objectSpread({}, action.data), {}, {\n            attributes: {}\n          })\n        };\n        return state.updateIn(['contentTypes', action.uid], function () {\n          return (0, _immutable.fromJS)(newSchema);\n        });\n      }\n\n    case actions.CREATE_COMPONENT_SCHEMA:\n      {\n        var _newSchema = {\n          uid: action.uid,\n          isTemporary: true,\n          category: action.componentCategory,\n          schema: _objectSpread(_objectSpread({}, action.data), {}, {\n            attributes: {}\n          })\n        };\n\n        if (action.shouldAddComponentToData) {\n          return state.updateIn(['components', action.uid], function () {\n            return (0, _immutable.fromJS)(_newSchema);\n          }).updateIn(['modifiedData', 'components', action.uid], function () {\n            return (0, _immutable.fromJS)(_newSchema);\n          });\n        }\n\n        return state.updateIn(['components', action.uid], function () {\n          return (0, _immutable.fromJS)(_newSchema);\n        });\n      }\n\n    case actions.DELETE_NOT_SAVED_TYPE:\n      {\n        // Doing so will also reset the modified and the initial data\n        return state.update('contentTypes', function () {\n          return state.get('initialContentTypes');\n        }).update('components', function () {\n          return state.get('initialComponents');\n        });\n      }\n\n    case actions.EDIT_ATTRIBUTE:\n      {\n        var _action$attributeToSe2 = action.attributeToSet,\n            _name = _action$attributeToSe2.name,\n            _rest = (0, _objectWithoutProperties2[\"default\"])(_action$attributeToSe2, [\"name\"]),\n            _forTarget = action.forTarget,\n            _targetUid = action.targetUid,\n            initialAttribute = action.initialAttribute;\n\n        var newState = state;\n        var initialAttributeName = (0, _lodash.get)(initialAttribute, ['name'], '');\n\n        var _pathToDataToEdit = ['component', 'contentType'].includes(_forTarget) ? [_forTarget] : [_forTarget, _targetUid];\n\n        return newState.updateIn(['modifiedData'].concat(_pathToDataToEdit, ['schema']), function (obj) {\n          var oppositeAttributeNameToRemove = null;\n          var oppositeAttributeNameToUpdate = null;\n          var oppositeAttributeNameToCreateBecauseOfNatureChange = null;\n          var oppositeAttributeToCreate = null;\n          var newObj = (0, _immutable.OrderedMap)(obj.get('attributes').keySeq().reduce(function (acc, current) {\n            var isEditingCurrentAttribute = current === initialAttributeName;\n\n            if (isEditingCurrentAttribute) {\n              var currentUid = state.getIn(['modifiedData'].concat(_pathToDataToEdit, ['uid']));\n              var isEditingRelation = (0, _lodash.has)(initialAttribute, 'nature');\n              var didChangeTargetRelation = initialAttribute.target !== _rest.target;\n              var didCreateInternalRelation = _rest.target === currentUid;\n              var nature = _rest.nature;\n              var initialNature = initialAttribute.nature;\n              var hadInternalRelation = initialAttribute.target === currentUid;\n              var didChangeRelationNature = initialAttribute.nature !== nature;\n              var shouldRemoveOppositeAttributeBecauseOfTargetChange = didChangeTargetRelation && !didCreateInternalRelation && hadInternalRelation && isEditingRelation;\n              var shouldRemoveOppositeAttributeBecauseOfNatureChange = didChangeRelationNature && hadInternalRelation && ['oneWay', 'manyWay'].includes(nature) && isEditingRelation;\n              var shouldUpdateOppositeAttributeBecauseOfNatureChange = !ONE_SIDE_RELATIONS.includes(initialNature) && !ONE_SIDE_RELATIONS.includes(nature) && hadInternalRelation && didCreateInternalRelation && isEditingRelation;\n              var shouldCreateOppositeAttributeBecauseOfNatureChange = ONE_SIDE_RELATIONS.includes(initialNature) && !ONE_SIDE_RELATIONS.includes(nature) && hadInternalRelation && didCreateInternalRelation && isEditingRelation;\n              var shouldCreateOppositeAttributeBecauseOfTargetChange = didChangeTargetRelation && didCreateInternalRelation && !ONE_SIDE_RELATIONS.includes(nature); // Update the opposite attribute name so it is removed at the end of the loop\n\n              if (shouldRemoveOppositeAttributeBecauseOfTargetChange || shouldRemoveOppositeAttributeBecauseOfNatureChange) {\n                oppositeAttributeNameToRemove = initialAttribute.targetAttribute;\n              } // Set the opposite attribute that will be updated when the loop attribute matches the name\n\n\n              if (shouldUpdateOppositeAttributeBecauseOfNatureChange || shouldCreateOppositeAttributeBecauseOfNatureChange || shouldCreateOppositeAttributeBecauseOfTargetChange) {\n                oppositeAttributeNameToUpdate = initialAttribute.targetAttribute;\n                oppositeAttributeNameToCreateBecauseOfNatureChange = _rest.targetAttribute;\n                oppositeAttributeToCreate = {\n                  nature: getOppositeNature(_rest.nature),\n                  target: _rest.target,\n                  unique: _rest.unique,\n                  // Leave this if we allow the required on the relation\n                  // required: rest.required,\n                  dominant: _rest.nature === 'manyToMany' ? !_rest.dominant : null,\n                  targetAttribute: _name,\n                  columnName: _rest.targetColumnName,\n                  targetColumnName: _rest.columnName\n                }; // First update the current attribute with the value\n\n                acc[_name] = (0, _immutable.fromJS)(_rest); // Then (if needed) create the opposite attribute the case is changing the relation from\n                // We do it here so keep the order of the attributes\n                // oneWay || manyWay to something another relation\n\n                if (shouldCreateOppositeAttributeBecauseOfNatureChange || shouldCreateOppositeAttributeBecauseOfTargetChange) {\n                  acc[oppositeAttributeNameToCreateBecauseOfNatureChange] = (0, _immutable.fromJS)(oppositeAttributeToCreate);\n                  oppositeAttributeToCreate = null;\n                  oppositeAttributeNameToCreateBecauseOfNatureChange = null;\n                }\n\n                return acc;\n              }\n\n              acc[_name] = (0, _immutable.fromJS)(_rest);\n            } else if (current === oppositeAttributeNameToUpdate) {\n              acc[oppositeAttributeNameToCreateBecauseOfNatureChange] = (0, _immutable.fromJS)(oppositeAttributeToCreate);\n            } else {\n              acc[current] = obj.getIn(['attributes', current]);\n            }\n\n            return acc;\n          }, {}));\n          var updatedObj; // Remove the opposite attribute\n\n          if (oppositeAttributeNameToRemove !== null) {\n            updatedObj = newObj.remove(oppositeAttributeNameToRemove);\n          } else {\n            updatedObj = newObj;\n          }\n\n          return obj.set('attributes', updatedObj);\n        });\n      }\n\n    case actions.GET_DATA_SUCCEEDED:\n      {\n        return state.update('components', function () {\n          return (0, _immutable.fromJS)(action.components);\n        }).update('initialComponents', function () {\n          return (0, _immutable.fromJS)(action.components);\n        }).update('initialContentTypes', function () {\n          return (0, _immutable.fromJS)(action.contentTypes);\n        }).update('contentTypes', function () {\n          return (0, _immutable.fromJS)(action.contentTypes);\n        }).update('reservedNames', function () {\n          return (0, _immutable.fromJS)(action.reservedNames);\n        }).update('isLoading', function () {\n          return false;\n        });\n      }\n\n    case actions.RELOAD_PLUGIN:\n      return initialState;\n\n    case actions.REMOVE_FIELD_FROM_DISPLAYED_COMPONENT:\n      {\n        var attributeToRemoveName = action.attributeToRemoveName,\n            componentUid = action.componentUid;\n        return state.removeIn(['modifiedData', 'components', componentUid, 'schema', 'attributes', attributeToRemoveName]);\n      }\n\n    case actions.REMOVE_COMPONENT_FROM_DYNAMIC_ZONE:\n      return state.removeIn(['modifiedData', 'contentType', 'schema', 'attributes', action.dzName, 'components', action.componentToRemoveIndex]);\n\n    case actions.REMOVE_FIELD:\n      {\n        var mainDataKey = action.mainDataKey,\n            _attributeToRemoveName = action.attributeToRemoveName;\n        var pathToAttributes = ['modifiedData', mainDataKey, 'schema', 'attributes'];\n        var pathToAttributeToRemove = [].concat(pathToAttributes, [_attributeToRemoveName]);\n        var attributeToRemoveData = state.getIn(pathToAttributeToRemove);\n        var isRemovingRelationAttribute = attributeToRemoveData.get('nature') !== undefined; // Only content types can have relations with themselves since\n        // components can only have oneWay or manyWay relations\n\n        var canTheAttributeToRemoveHaveARelationWithItself = mainDataKey === 'contentType';\n\n        if (isRemovingRelationAttribute && canTheAttributeToRemoveHaveARelationWithItself) {\n          var _attributeToRemoveDat = attributeToRemoveData.toJS(),\n              target = _attributeToRemoveDat.target,\n              nature = _attributeToRemoveDat.nature,\n              targetAttribute = _attributeToRemoveDat.targetAttribute;\n\n          var uid = state.getIn(['modifiedData', 'contentType', 'uid']);\n          var shouldRemoveOppositeAttribute = target === uid && !ONE_SIDE_RELATIONS.includes(nature);\n\n          if (shouldRemoveOppositeAttribute) {\n            return state.removeIn(pathToAttributeToRemove).removeIn([].concat(pathToAttributes, [targetAttribute]));\n          }\n        }\n\n        return state.removeIn(pathToAttributeToRemove).updateIn([].concat(pathToAttributes), function (attributes) {\n          return attributes.keySeq().reduce(function (acc, current) {\n            if (acc.getIn([current, 'targetField']) === _attributeToRemoveName) {\n              return acc.removeIn([current, 'targetField']);\n            }\n\n            return acc;\n          }, attributes);\n        });\n      }\n\n    case actions.SET_MODIFIED_DATA:\n      {\n        var _newState = state.update('isLoadingForDataToBeSet', function () {\n          return false;\n        }).update('initialData', function () {\n          return (0, _immutable.fromJS)(action.schemaToSet);\n        }).update('modifiedData', function () {\n          return (0, _immutable.fromJS)(action.schemaToSet);\n        }); // Reset the state with the initial data\n        // All created components and content types will be lost\n\n\n        if (!action.hasJustCreatedSchema) {\n          _newState = _newState.update('components', function () {\n            return state.get('initialComponents');\n          }).update('contentTypes', function () {\n            return state.get('initialContentTypes');\n          });\n        }\n\n        return _newState;\n      }\n\n    case actions.UPDATE_SCHEMA:\n      {\n        var _action$data = action.data,\n            _name2 = _action$data.name,\n            collectionName = _action$data.collectionName,\n            category = _action$data.category,\n            icon = _action$data.icon,\n            kind = _action$data.kind,\n            schemaType = action.schemaType,\n            _uid = action.uid;\n\n        var _newState2 = state.updateIn(['modifiedData', schemaType], function (obj) {\n          var updatedObj = obj.updateIn(['schema', 'name'], function () {\n            return _name2;\n          }).updateIn(['schema', 'collectionName'], function () {\n            return collectionName;\n          });\n\n          if (action.schemaType === 'component') {\n            updatedObj = updatedObj.update('category', function () {\n              return category;\n            }).updateIn(['schema', 'icon'], function () {\n              return icon;\n            });\n          }\n\n          if (action.schemaType === 'contentType') {\n            updatedObj = updatedObj.updateIn(['schema', 'kind'], function () {\n              return kind;\n            });\n          }\n\n          return updatedObj;\n        });\n\n        if (schemaType === 'component') {\n          _newState2 = _newState2.updateIn(['components'], function (obj) {\n            return obj.update(_uid, function () {\n              return _newState2.getIn(['modifiedData', 'component']);\n            });\n          });\n        }\n\n        return _newState2;\n      }\n\n    default:\n      return state;\n  }\n};\n\nvar _default = reducer;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/Users/joaovictorlobao/prefeituramaragogistrapi/.cache/plugins/strapi-plugin-content-type-builder/admin/src/containers/DataManagerProvider/reducer.js"],"names":["initialState","components","contentTypes","initialComponents","initialContentTypes","initialData","modifiedData","reservedNames","isLoading","isLoadingForDataToBeSet","ONE_SIDE_RELATIONS","getOppositeNature","originalNature","addComponentsToState","state","componentToAddUid","objToUpdate","newObj","componentToAdd","getIn","isTemporaryComponent","get","componentToAddSchema","hasComponentAlreadyBeenAdded","undefined","set","nestedComponents","toJS","forEach","componentUid","isTemporary","hasNestedComponentAlreadyBeenAdded","reducer","action","type","actions","ADD_ATTRIBUTE","attributeToSet","name","rest","forTarget","targetUid","createComponent","pathToDataToEdit","includes","updateIn","obj","target","nature","currentUid","oppositeAttribute","unique","dominant","targetAttribute","columnName","targetColumnName","update","existingCompos","shouldAddComponentToData","component","ADD_CREATED_COMPONENT_TO_DYNAMIC_ZONE","dynamicZoneTarget","componentsToAdd","list","concat","CANCEL_CHANGES","CHANGE_DYNAMIC_ZONE_COMPONENTS","newComponents","old","componentsSchema","reduce","acc","current","CREATE_SCHEMA","newSchema","uid","schema","data","attributes","CREATE_COMPONENT_SCHEMA","category","componentCategory","DELETE_NOT_SAVED_TYPE","EDIT_ATTRIBUTE","initialAttribute","newState","initialAttributeName","oppositeAttributeNameToRemove","oppositeAttributeNameToUpdate","oppositeAttributeNameToCreateBecauseOfNatureChange","oppositeAttributeToCreate","keySeq","isEditingCurrentAttribute","isEditingRelation","didChangeTargetRelation","didCreateInternalRelation","initialNature","hadInternalRelation","didChangeRelationNature","shouldRemoveOppositeAttributeBecauseOfTargetChange","shouldRemoveOppositeAttributeBecauseOfNatureChange","shouldUpdateOppositeAttributeBecauseOfNatureChange","shouldCreateOppositeAttributeBecauseOfNatureChange","shouldCreateOppositeAttributeBecauseOfTargetChange","updatedObj","remove","GET_DATA_SUCCEEDED","RELOAD_PLUGIN","REMOVE_FIELD_FROM_DISPLAYED_COMPONENT","attributeToRemoveName","removeIn","REMOVE_COMPONENT_FROM_DYNAMIC_ZONE","dzName","componentToRemoveIndex","REMOVE_FIELD","mainDataKey","pathToAttributes","pathToAttributeToRemove","attributeToRemoveData","isRemovingRelationAttribute","canTheAttributeToRemoveHaveARelationWithItself","shouldRemoveOppositeAttribute","SET_MODIFIED_DATA","schemaToSet","hasJustCreatedSchema","UPDATE_SCHEMA","collectionName","icon","kind","schemaType"],"mappings":"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","sourcesContent":["import { fromJS, OrderedMap } from 'immutable';\nimport { get, has } from 'lodash';\nimport makeUnique from '../../utils/makeUnique';\nimport retrieveComponentsFromSchema from './utils/retrieveComponentsFromSchema';\nimport * as actions from './constants';\n\nconst initialState = fromJS({\n  components: {},\n  contentTypes: {},\n  initialComponents: {},\n  initialContentTypes: {},\n  initialData: {},\n  modifiedData: {},\n  reservedNames: {},\n  isLoading: true,\n  isLoadingForDataToBeSet: true,\n});\n\nconst ONE_SIDE_RELATIONS = ['oneWay', 'manyWay'];\n\nconst getOppositeNature = originalNature => {\n  if (originalNature === 'manyToOne') {\n    return 'oneToMany';\n  }\n\n  if (originalNature === 'oneToMany') {\n    return 'manyToOne';\n  }\n\n  return originalNature;\n};\n\nconst addComponentsToState = (state, componentToAddUid, objToUpdate) => {\n  let newObj = objToUpdate;\n  const componentToAdd = state.getIn(['components', componentToAddUid]);\n  const isTemporaryComponent = componentToAdd.get('isTemporary');\n  const componentToAddSchema = componentToAdd.getIn(['schema', 'attributes']);\n  const hasComponentAlreadyBeenAdded =\n    state.getIn(['modifiedData', 'components', componentToAddUid]) !== undefined;\n\n  // created components are already in the modifiedData.components\n  // We don't add them because all modifications will be lost\n  if (isTemporaryComponent || hasComponentAlreadyBeenAdded) {\n    return newObj;\n  }\n\n  // Add the added components to the modifiedData.compontnes\n  newObj = newObj.set(componentToAddUid, componentToAdd);\n  const nestedComponents = retrieveComponentsFromSchema(\n    componentToAddSchema.toJS(),\n    state.get('components').toJS()\n  );\n\n  // We need to add the nested components to the modifiedData.components as well\n  nestedComponents.forEach(componentUid => {\n    const isTemporary = state.getIn(['components', componentUid, 'isTemporary']) || false;\n    const hasNestedComponentAlreadyBeenAdded =\n      state.getIn(['modifiedData', 'components', componentUid]) !== undefined;\n\n    // Same logic here otherwise we will lose the modifications added to the components\n    if (!isTemporary && !hasNestedComponentAlreadyBeenAdded) {\n      newObj = newObj.set(componentUid, state.getIn(['components', componentUid]));\n    }\n  });\n\n  return newObj;\n};\n\nconst reducer = (state = initialState, action) => {\n  switch (action.type) {\n    case actions.ADD_ATTRIBUTE: {\n      const {\n        attributeToSet: { name, ...rest },\n        forTarget,\n        targetUid,\n      } = action;\n      delete rest.createComponent;\n\n      const pathToDataToEdit = ['component', 'contentType'].includes(forTarget)\n        ? [forTarget]\n        : [forTarget, targetUid];\n\n      return state\n        .updateIn(['modifiedData', ...pathToDataToEdit, 'schema', 'attributes', name], () => {\n          return fromJS(rest);\n        })\n        .updateIn(['modifiedData', ...pathToDataToEdit, 'schema', 'attributes'], obj => {\n          const type = get(rest, 'type', 'relation');\n          const target = get(rest, 'target', null);\n          const nature = get(rest, 'nature', null);\n          const currentUid = state.getIn(['modifiedData', ...pathToDataToEdit, 'uid']);\n\n          // When the user in creating a relation with the same content type we need to create another attribute\n          // that is the opposite of the created one\n          if (\n            type === 'relation' &&\n            nature !== 'oneWay' &&\n            nature !== 'manyWay' &&\n            target === currentUid\n          ) {\n            const oppositeAttribute = {\n              nature: getOppositeNature(nature),\n              target,\n              unique: rest.unique,\n              // Leave this if we allow the required on the relation\n              // required: rest.required,\n              dominant: nature === 'manyToMany' ? !rest.dominant : null,\n              targetAttribute: name,\n              columnName: rest.targetColumnName,\n              targetColumnName: rest.columnName,\n            };\n\n            return obj.update(rest.targetAttribute, () => {\n              return fromJS(oppositeAttribute);\n            });\n          }\n\n          return obj;\n        })\n        .updateIn(['modifiedData', 'components'], existingCompos => {\n          if (action.shouldAddComponentToData) {\n            return addComponentsToState(state, rest.component, existingCompos);\n          }\n\n          return existingCompos;\n        });\n    }\n    case actions.ADD_CREATED_COMPONENT_TO_DYNAMIC_ZONE: {\n      const { dynamicZoneTarget, componentsToAdd } = action;\n\n      return state.updateIn(\n        ['modifiedData', 'contentType', 'schema', 'attributes', dynamicZoneTarget, 'components'],\n        list => {\n          return list.concat(componentsToAdd);\n        }\n      );\n    }\n    case actions.CANCEL_CHANGES: {\n      return state\n        .update('modifiedData', () => state.get('initialData'))\n        .update('components', () => state.get('initialComponents'));\n    }\n    case actions.CHANGE_DYNAMIC_ZONE_COMPONENTS: {\n      const { dynamicZoneTarget, newComponents } = action;\n\n      return state\n        .updateIn(\n          ['modifiedData', 'contentType', 'schema', 'attributes', dynamicZoneTarget, 'components'],\n          list => {\n            return fromJS(makeUnique([...list.toJS(), ...newComponents]));\n          }\n        )\n        .updateIn(['modifiedData', 'components'], old => {\n          const componentsSchema = newComponents.reduce((acc, current) => {\n            return addComponentsToState(state, current, acc);\n          }, old);\n\n          return componentsSchema;\n        });\n    }\n\n    case actions.CREATE_SCHEMA: {\n      const newSchema = {\n        uid: action.uid,\n        isTemporary: true,\n        schema: {\n          ...action.data,\n          attributes: {},\n        },\n      };\n\n      return state.updateIn(['contentTypes', action.uid], () => fromJS(newSchema));\n    }\n    case actions.CREATE_COMPONENT_SCHEMA: {\n      const newSchema = {\n        uid: action.uid,\n        isTemporary: true,\n        category: action.componentCategory,\n        schema: {\n          ...action.data,\n          attributes: {},\n        },\n      };\n\n      if (action.shouldAddComponentToData) {\n        return state\n          .updateIn(['components', action.uid], () => fromJS(newSchema))\n          .updateIn(['modifiedData', 'components', action.uid], () => fromJS(newSchema));\n      }\n\n      return state.updateIn(['components', action.uid], () => fromJS(newSchema));\n    }\n    case actions.DELETE_NOT_SAVED_TYPE: {\n      // Doing so will also reset the modified and the initial data\n      return state\n        .update('contentTypes', () => state.get('initialContentTypes'))\n        .update('components', () => state.get('initialComponents'));\n    }\n    case actions.EDIT_ATTRIBUTE: {\n      const {\n        attributeToSet: { name, ...rest },\n        forTarget,\n        targetUid,\n        initialAttribute,\n      } = action;\n      let newState = state;\n\n      const initialAttributeName = get(initialAttribute, ['name'], '');\n      const pathToDataToEdit = ['component', 'contentType'].includes(forTarget)\n        ? [forTarget]\n        : [forTarget, targetUid];\n\n      return newState.updateIn(['modifiedData', ...pathToDataToEdit, 'schema'], obj => {\n        let oppositeAttributeNameToRemove = null;\n        let oppositeAttributeNameToUpdate = null;\n        let oppositeAttributeNameToCreateBecauseOfNatureChange = null;\n        let oppositeAttributeToCreate = null;\n\n        const newObj = OrderedMap(\n          obj\n            .get('attributes')\n            .keySeq()\n            .reduce((acc, current) => {\n              const isEditingCurrentAttribute = current === initialAttributeName;\n\n              if (isEditingCurrentAttribute) {\n                const currentUid = state.getIn(['modifiedData', ...pathToDataToEdit, 'uid']);\n                const isEditingRelation = has(initialAttribute, 'nature');\n                const didChangeTargetRelation = initialAttribute.target !== rest.target;\n                const didCreateInternalRelation = rest.target === currentUid;\n                const nature = rest.nature;\n                const initialNature = initialAttribute.nature;\n                const hadInternalRelation = initialAttribute.target === currentUid;\n                const didChangeRelationNature = initialAttribute.nature !== nature;\n                const shouldRemoveOppositeAttributeBecauseOfTargetChange =\n                  didChangeTargetRelation &&\n                  !didCreateInternalRelation &&\n                  hadInternalRelation &&\n                  isEditingRelation;\n                const shouldRemoveOppositeAttributeBecauseOfNatureChange =\n                  didChangeRelationNature &&\n                  hadInternalRelation &&\n                  ['oneWay', 'manyWay'].includes(nature) &&\n                  isEditingRelation;\n                const shouldUpdateOppositeAttributeBecauseOfNatureChange =\n                  !ONE_SIDE_RELATIONS.includes(initialNature) &&\n                  !ONE_SIDE_RELATIONS.includes(nature) &&\n                  hadInternalRelation &&\n                  didCreateInternalRelation &&\n                  isEditingRelation;\n                const shouldCreateOppositeAttributeBecauseOfNatureChange =\n                  ONE_SIDE_RELATIONS.includes(initialNature) &&\n                  !ONE_SIDE_RELATIONS.includes(nature) &&\n                  hadInternalRelation &&\n                  didCreateInternalRelation &&\n                  isEditingRelation;\n                const shouldCreateOppositeAttributeBecauseOfTargetChange =\n                  didChangeTargetRelation &&\n                  didCreateInternalRelation &&\n                  !ONE_SIDE_RELATIONS.includes(nature);\n\n                // Update the opposite attribute name so it is removed at the end of the loop\n                if (\n                  shouldRemoveOppositeAttributeBecauseOfTargetChange ||\n                  shouldRemoveOppositeAttributeBecauseOfNatureChange\n                ) {\n                  oppositeAttributeNameToRemove = initialAttribute.targetAttribute;\n                }\n\n                // Set the opposite attribute that will be updated when the loop attribute matches the name\n                if (\n                  shouldUpdateOppositeAttributeBecauseOfNatureChange ||\n                  shouldCreateOppositeAttributeBecauseOfNatureChange ||\n                  shouldCreateOppositeAttributeBecauseOfTargetChange\n                ) {\n                  oppositeAttributeNameToUpdate = initialAttribute.targetAttribute;\n                  oppositeAttributeNameToCreateBecauseOfNatureChange = rest.targetAttribute;\n\n                  oppositeAttributeToCreate = {\n                    nature: getOppositeNature(rest.nature),\n                    target: rest.target,\n                    unique: rest.unique,\n                    // Leave this if we allow the required on the relation\n                    // required: rest.required,\n                    dominant: rest.nature === 'manyToMany' ? !rest.dominant : null,\n                    targetAttribute: name,\n                    columnName: rest.targetColumnName,\n                    targetColumnName: rest.columnName,\n                  };\n\n                  // First update the current attribute with the value\n                  acc[name] = fromJS(rest);\n\n                  // Then (if needed) create the opposite attribute the case is changing the relation from\n                  // We do it here so keep the order of the attributes\n                  // oneWay || manyWay to something another relation\n                  if (\n                    shouldCreateOppositeAttributeBecauseOfNatureChange ||\n                    shouldCreateOppositeAttributeBecauseOfTargetChange\n                  ) {\n                    acc[oppositeAttributeNameToCreateBecauseOfNatureChange] = fromJS(\n                      oppositeAttributeToCreate\n                    );\n\n                    oppositeAttributeToCreate = null;\n                    oppositeAttributeNameToCreateBecauseOfNatureChange = null;\n                  }\n\n                  return acc;\n                }\n\n                acc[name] = fromJS(rest);\n              } else if (current === oppositeAttributeNameToUpdate) {\n                acc[oppositeAttributeNameToCreateBecauseOfNatureChange] = fromJS(\n                  oppositeAttributeToCreate\n                );\n              } else {\n                acc[current] = obj.getIn(['attributes', current]);\n              }\n\n              return acc;\n            }, {})\n        );\n\n        let updatedObj;\n\n        // Remove the opposite attribute\n        if (oppositeAttributeNameToRemove !== null) {\n          updatedObj = newObj.remove(oppositeAttributeNameToRemove);\n        } else {\n          updatedObj = newObj;\n        }\n\n        return obj.set('attributes', updatedObj);\n      });\n    }\n\n    case actions.GET_DATA_SUCCEEDED: {\n      return state\n        .update('components', () => fromJS(action.components))\n        .update('initialComponents', () => fromJS(action.components))\n        .update('initialContentTypes', () => fromJS(action.contentTypes))\n        .update('contentTypes', () => fromJS(action.contentTypes))\n        .update('reservedNames', () => fromJS(action.reservedNames))\n\n        .update('isLoading', () => false);\n    }\n    case actions.RELOAD_PLUGIN:\n      return initialState;\n    case actions.REMOVE_FIELD_FROM_DISPLAYED_COMPONENT: {\n      const { attributeToRemoveName, componentUid } = action;\n\n      return state.removeIn([\n        'modifiedData',\n        'components',\n        componentUid,\n        'schema',\n        'attributes',\n        attributeToRemoveName,\n      ]);\n    }\n    case actions.REMOVE_COMPONENT_FROM_DYNAMIC_ZONE:\n      return state.removeIn([\n        'modifiedData',\n        'contentType',\n        'schema',\n        'attributes',\n        action.dzName,\n        'components',\n        action.componentToRemoveIndex,\n      ]);\n    case actions.REMOVE_FIELD: {\n      const { mainDataKey, attributeToRemoveName } = action;\n      const pathToAttributes = ['modifiedData', mainDataKey, 'schema', 'attributes'];\n      const pathToAttributeToRemove = [...pathToAttributes, attributeToRemoveName];\n\n      const attributeToRemoveData = state.getIn(pathToAttributeToRemove);\n\n      const isRemovingRelationAttribute = attributeToRemoveData.get('nature') !== undefined;\n      // Only content types can have relations with themselves since\n      // components can only have oneWay or manyWay relations\n      const canTheAttributeToRemoveHaveARelationWithItself = mainDataKey === 'contentType';\n\n      if (isRemovingRelationAttribute && canTheAttributeToRemoveHaveARelationWithItself) {\n        const { target, nature, targetAttribute } = attributeToRemoveData.toJS();\n        const uid = state.getIn(['modifiedData', 'contentType', 'uid']);\n        const shouldRemoveOppositeAttribute =\n          target === uid && !ONE_SIDE_RELATIONS.includes(nature);\n\n        if (shouldRemoveOppositeAttribute) {\n          return state\n            .removeIn(pathToAttributeToRemove)\n            .removeIn([...pathToAttributes, targetAttribute]);\n        }\n      }\n\n      return state.removeIn(pathToAttributeToRemove).updateIn([...pathToAttributes], attributes => {\n        return attributes.keySeq().reduce((acc, current) => {\n          if (acc.getIn([current, 'targetField']) === attributeToRemoveName) {\n            return acc.removeIn([current, 'targetField']);\n          }\n\n          return acc;\n        }, attributes);\n      });\n    }\n    case actions.SET_MODIFIED_DATA: {\n      let newState = state\n        .update('isLoadingForDataToBeSet', () => false)\n        .update('initialData', () => fromJS(action.schemaToSet))\n        .update('modifiedData', () => fromJS(action.schemaToSet));\n\n      // Reset the state with the initial data\n      // All created components and content types will be lost\n      if (!action.hasJustCreatedSchema) {\n        newState = newState\n          .update('components', () => state.get('initialComponents'))\n          .update('contentTypes', () => state.get('initialContentTypes'));\n      }\n\n      return newState;\n    }\n    case actions.UPDATE_SCHEMA: {\n      const {\n        data: { name, collectionName, category, icon, kind },\n        schemaType,\n        uid,\n      } = action;\n\n      let newState = state.updateIn(['modifiedData', schemaType], obj => {\n        let updatedObj = obj\n          .updateIn(['schema', 'name'], () => name)\n          .updateIn(['schema', 'collectionName'], () => collectionName);\n\n        if (action.schemaType === 'component') {\n          updatedObj = updatedObj\n            .update('category', () => category)\n            .updateIn(['schema', 'icon'], () => icon);\n        }\n        if (action.schemaType === 'contentType') {\n          updatedObj = updatedObj.updateIn(['schema', 'kind'], () => kind);\n        }\n\n        return updatedObj;\n      });\n\n      if (schemaType === 'component') {\n        newState = newState.updateIn(['components'], obj => {\n          return obj.update(uid, () => newState.getIn(['modifiedData', 'component']));\n        });\n      }\n\n      return newState;\n    }\n    default:\n      return state;\n  }\n};\n\nexport default reducer;\nexport { addComponentsToState, initialState };\n"]},"metadata":{},"sourceType":"script"}